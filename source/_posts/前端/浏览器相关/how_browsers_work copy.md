---
layout: pages
title: 浏览器工作原理
date: 2017-05-26 22:04:03
tags:
      - browser 
categories: 前端
---
## 摘要 ##
<!--**<p style="color:#15A05D;display：block"></p>**-->
**<p style="color:#15A05D;display：block">本文主要是通过8个方面来讲解浏览器到底是如何工作的。学习浏览器工作原理时最好有编译原理的基础，这样有助于你更好的理解浏览器是如何解析页面中的代码的。此外，在学习过程中你将会了解到什么时候呈现树，如何实现DOM树构建，浏览器是如何实现页面布局的，以及如何处理js等</p>**

> 在 IE 占据 90% 市场份额的年代，我们除了把浏览器当成一个“黑箱”，什么也做不了。但是现在，开放源代码的浏览器拥有了过半的市场份额，因此，是时候来揭开神秘的面纱，一探网络浏览器的内幕了。呃，里面只有数以百万行计的 C++ 代码...

## 简介及浏览器基础知识 ##
### 浏览器的高层结构 ###
浏览器的主要组件有7个，分别为 `用户界面` , `浏览器引擎` , `呈现引擎` , `网络` , `用户界面后端` , `Javascript解释器` , `数据储存` 。结构图如下如所示：

![](how_browsers_work/layers.png)
(图0-1: 浏览器的主要组件)

- **`用户界面（User Interface）`** 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您的请求外，其他显示的各个部分都属于用户界面。
- **`浏览器引擎（Browser Engine）`** 在用户界面和和呈现引擎之间传送指令。	
- **`呈现引擎（Rendering Engine）`** 负责显示请求的内容。如果请求内容是HTML，它就负责解析HTML和CSS内容，并将解析后内容显示在屏幕上。
- **`网络（Networking）`** 用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供 `底层实现` 。
- **`用户界面后端（UI Backend）`** 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
- **`Javascript解释器（Javascript Interpreter）`** 用于解释和执行javascript代码。
- **`数据存储（Date Persistence）`** 这是持久层。浏览器需要在硬盘上保存各种数据，例如 `Cookie` 。 `HTML5` 定义了 `“网络数据库”` ，这是一个完整（但是轻便）的浏览器内数据库。

## 一、呈现引擎 ##
### Introduction ###
>`呈现引擎` ，顾名思义就是在浏览器上显示用户请求的内容。默认情况下呈现引擎可以显示 `HTML` , `XML` 文档与图片。通过插件还可以显示 `PDF`。

当然呈现引擎很重的作用是： `显示使用 CSS 格式化的 HTML 内容和图片`。

### 主流程（渲染流程） ###
呈现引擎一开始会从 `网络层` 获取请求文档的内容，内容大小一般限制在8000块以内。下图表示呈现引擎的的基本流程

![](how_browsers_work/flow.png)
（图1-1 呈现引擎的的基本流程）
先渲染 HTML 文件 `构建DOM树` ，再渲染 CSS 文件 `构建render树`，render树构建好之后执行布局过程，它将 `确定每个元素的确切坐标` ， 再下一步就是 `绘制` （既遍历render树并根据ui后端层绘制每个节点）。

**<p style="color:red;display：block">这是一个渐进过程，为了减少等待时间提升用户体验，呈现引擎力求尽快将内容显示在屏幕上。它在等个 HTML 文档解析完毕之前就会构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并呈现出来。</p>**

![](how_browsers_work/webkitflow.png)
(图2-1 weikit 主流程示例)

----

## 二、解析和DOM树构建 ##
### 解析 - 综述 ###
#### - Part One  解析 ####
>解析文档是将文档转化为更有意义的结构,也就是可以让代码理解和使用的结构。
解析得到的结果通常称作 `解析树` 或 `语法树`。

示例-解析 `2 + 3 - 1` 这个表达式,会返回下面的树：
![](how_browsers_work/parseTree.png)
(图2-2 数学表达式树节点)

#### - Part Two 文法 ####
本章节中重点理解需要理解的概念是 `上下文无关文法` 。
`上下文无关文法` 不是人类的语言，不具有 `二义性` , `无歧义` 。例如 `汉语` 就是很明显的 `上下文相关文法` ，每个字的含义要通过上下文才能具体确定其含义。

#### - Part Three 解析器和词法分析器的组合 ####
**<p style="color:#15A05D;display：block">解析过程分为 词法分析、 语法分析 两个过程</p>**
![](how_browsers_work/parseProcess.png)
(图2-3 从源文档到解析树)

#### - Part Four 翻译 ####
>很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。


### HTML解析器 ###
#### - Part One 简单介绍 ####
HTML解析器的任务就是讲HTML标记解析成解析树

上下文无关文法可以用BNF等格式进行定义。但是所有常规解析器都不适用于 HTML ,因为HTML `不是上下文无关文法`。
**<p style="color:red;display：block">定义 HTML 的正规格式是：DTD ，与 XML 类似。但是由于 HTML 需要有更大的容错性所以与XML的严格语法还是有区别的，故不能用类XML解析器来解析HTML </p>**

#### - Part Two DOM ####
>解析器输出的的 “解析树” 是由DOM元素和属性节点构成的树结构。DOM 是文档对象模型,它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。
解析树的根节点是“Document”对象。

DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：
```html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```
上述代码，可翻译成如下DOM树：
![](how_browsers_work/domTree.png)

#### -Part Three 解析算法 ####
HTML 无法用常规的 `自上而下` 或 `自下而上` 的解析器进行解析
Reason:
      `1. 语言的宽容本质`
      `2. 浏览器历来对一些常见的无效HTML用法采取包容态度`
      `3. 解析过程需要不断反复，如果脚本包含document.writr() 等...`
**浏览器创建了自定义解析器来解析HTML,解析算法由两个阶段组成：`标记化` 和 `树构建`**
![](how_browsers_work/parseHTML.png)
(图2-5 HTML解析流程 Tokeniser是词法分析过程)

##### （1）标记化算法 #####
**标记化过程就是词法分析过程**
>该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。

##### （2）树构建算法 #####
>在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”

**让我们来看看示例输入的树构建过程：:**
```html
<html>
  <body>
    Hello world
  </body>
</html>
```
- 树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是 `“initial mode”` 。接收 HTML 标记后转为 `“before html”` 模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。
- 然后状态将改为“before head”。此时我们接收 `“body”` 标记。即使我们的示例中没有 `“head”标记` ，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。
- 现在我们进入了 `“in head”` 模式，然后转入 `“after head”` 模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为“in body”。
- 现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。
- 接收 body 结束标记会触发“after body”模式。现在我们将接收 HTML 结束标记，然后进入 `“after after body”` 模式。接收到文件结束标记后，解析过程就此结束。
![](how_browsers_work/treeConstruction.gif)
(图2-6 HTML树构建)

#### - Part Four 解析结束后的操作 ####
浏览器将文档标注为交互状态，并开始解析处于 `“defferred”`（文档解析完成后才执行的脚本） 模式的脚本，然后文档设置为 `“完成”`

### CSS解析 ###
**<p style="color:#15A05D;display：block">CSS是上下文无关文法,语法是采用 BNF 格式描述的</p>**

### 处理脚本和样式被顺序 ###
#### -Part One 脚本 ####
网络的模型是同步的，解析器遇到 script标签 会立即解析并执行脚本，此时文档的解析将会停止直到脚本执行完毕。
在HTML5 中 **script defer 不会使文档停止解析**
**script async 将脚本标记为异步，以便由其他线程解析并执行**
#### -Part Two 预解析 ####
**<p style="color:#15A05D;display：block">在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。
预解析不会修改DOM树，而是将这项工作交给主解析器处理。</p>**
#### -Part Three 样式表 ####
>理论上来说，应用样式表不会更改 DOM 树，但是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。

- Firefox 在样式表加载和解析的过程中，会禁止所有脚本。
- Firefox 在样式表加载和解析的过程中，会禁止所有脚本

----

## 三、呈现树构建 ##
### 简要介绍 ###
在DOM树构建的同时，浏览器会构建另一个树结构：呈现树(Render Tree)。
**<p style="color:#15A05D;display：block">呈现树是由可视化元素按照其显示顺序而组成的树，也是文档的可视化元素。（呈现树的主要作用是 按照正确的顺序绘制内容）</p>**

【呈现器/呈现对象】：WebKit将呈现树中的元素成为 `呈现器` 或者 `呈现对象`。呈现器知道如何布局并将自身及其子元素绘制出来。
**每一个呈现器都代表了一个矩形区域，通常对应于相关节点的CSS呈现树和DOM树的关系**
### 呈现树和DOM树的关系 ###
>呈现器和DOM元素相对应，但是不是一一对应。非可视化的DOM元素（比如head）是不会插入呈现树当中的。

**<p style="color:red;display：block">如果display=“none” ,那么也不会显示在呈现树当中。但是 visibility="hidden" 仍然会显示
呈现器在树中的位置与DOM节点不同，浮动定位和绝对定位的元素就是这样,他们处于正常流之外,放置在树中的其他地方,并映射到真正的框架,而放在原位的是站位框架。</p>**
![](how_browsers_work/render_DOM_tree.png)
(图3-1 呈现树及其对应的DOM树 初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。)

### 构建呈现树流程 ###
>在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。

处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。

### 样式计算 ###
`(注：浏览器允许用户自定义样式)`
**计算难点**
- 样式数据是一个超大的数据结构，储存了无数的样式属性，可能造成内存问题。
- 如果不进行优化，为每一个元素查询匹配规则会造成性能问题
- 应用规则涉及到相当复杂的层叠规则

----

## 四、布局 ##
>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。
HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (3.5)。
坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。
布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。
根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。
所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。

----

## 五、绘制 ##
>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。
### 全局绘制和增量绘制 ###
>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。

-----

## 六、动态变化 ##
>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。

-----

## 七、呈现引擎的线程 ##
**<p style="color:red;display：block">Rendering Engine 采用了单线程。除了网络操作，其他操作都是在单线程中进行了
网络操作可由多个并行线程执行。并行连接数是有限的（通常2-6个）</p>
**时间循环**
**<p style="color:#16A05D;display：block">浏览器主线程就是时间循环。它是一个无限循环，永远处于接收处理状态，等待事件（如布局盒绘制时间）发生，并进行处理。</p>

-----

## 八、CSS2可视化模型 ##
### 画布 ###
“画布”这一术语是指“用来呈现格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。
画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。

### CSS 框模型 ###
CSS 框模型描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。 
每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。
![](how_browsers_work/css_div.jpg)
(图8-1 CSS2 框模型)